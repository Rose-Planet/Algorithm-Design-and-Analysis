# 1. 分类整理

### 1. 1 插入排序

- **时间复杂度**：
  - 平均情况复杂度：O(n²)
  - 最坏情况复杂度：O(n²)（完全逆序）
  - 最好情况复杂度：O(n)（已排序的数组）
- **空间复杂度**：O(1)
- **特点**：适合数据量较小或部分有序的数据，原地排序。

### 1. 2 冒泡排序

- **时间复杂度**：
  - 平均情况复杂度：O(n²)
  - 最坏情况复杂度：O(n²)
  - 最好情况复杂度：O(n)（已排序）
- **空间复杂度**：O(1)
- **特点**：算法简单，但效率低，几乎不用于大规模数据排序。

### 1.3 选择排序

- **时间复杂度**：
  - 平均情况复杂度：O(n²)
  - 最坏情况复杂度：O(n²)
  - 最好情况复杂度：O(n²)
- **空间复杂度**：O(1)
- **特点**：每次找到剩余元素中最小的放到前面，移动次数相对较少，但效率低。

### 1.4 合并排序

- **时间复杂度**：
  - 平均情况复杂度：O(n log n)
  - 最坏情况复杂度：O(n log n)
  - 最好情况复杂度：O(n log n)
- **空间复杂度**：O(n)（需要辅助数组）
- **特点**：基于分治思想，性能稳定，但需要额外空间。

### 1.5 快速排序

- **时间复杂度**：
  - 平均情况复杂度：O(n log n)
  - 最坏情况复杂度：O(n²)（每次选到最差的基准元素时）
  - 最好情况复杂度：O(n log n)
- **空间复杂度**：
  - O(log n)（递归调用栈的空间复杂度，原地排序）
- **特点**：实际应用中最常用的排序算法之一，基于分治法，性能通常优于O(n log n)的排序算法。

### 1.6 堆排序

- **时间复杂度**：
  - 平均情况复杂度：O(n log n)
  - 最坏情况复杂度：O(n log n)
  - 最好情况复杂度：O(n log n)
- **空间复杂度**：O(1)
- **特点**：利用堆这种数据结构的性质实现，适合大数据排序，尤其适用于需要原地排序且情况复杂度为O(n log n)的情况。

### 1.7 希尔排序

- **时间复杂度**：
  - 平均情况复杂度：根据间隔序列，常见为 O(n^(3/2)) ~ O(n^(5/4))
  - 最坏情况复杂度：O(n²)
  - 最好情况复杂度：O(n log n)
- **空间复杂度**：O(1)
- **特点**：基于插入排序的改进版本，通过间隔逐渐减小的分组进行排序。



------

# 2. 按照复杂性函数排序

1. **O(n)**：
   - **插入排序**（最好情况）
   - **冒泡排序**（最好情况）
   
2. **O(n log n)**：
   - **合并排序**
   - **快速排序**（平均情况）
   - **堆排序**
   
3. **O(n^(3/2))** ~ **O(n log n)**：
   
   - **希尔排序**（平均情况）
   
4. **O(n²)**：
   
   - **插入排序**（最坏情况）
   - **冒泡排序**（平均情况）
   - **选择排序**
   - **快速排序**（最坏情况）
   - **希尔排序**（最坏情况）
   
   
----

# 3. 空间复杂度分类

- **O(1)（原地排序）**：插入排序、冒泡排序、选择排序、快速排序、堆排序、希尔排序
- **O(n)（需要额外空间）**：合并排序



------

# 4. 总结

- **快速排序**和**堆排序**在大多数情况下表现最好，情况复杂度是O(n log n)，但快速排序在最坏情况下情况复杂度为O(n²)。
- **合并排序**稳定且情况复杂度为O(n log n)，但需要额外的空间，因此不适合原地排序的需求。
- **插入排序**和**冒泡排序**在数据量较小时表现不错，且实现简单，但在大规模数据时效率较低。