# 第一小问

对于本题，每一个格子 `(i, j)` 的最优解依赖于其上方 `(i-1, j)` 和左方 `(i, j-1)` 的最优解。我们可以得出下面的递推公式：

- 如果要到达 `(i, j)`，只能从上面或左边走过来。因此递归表达式：
  						$
        			dp[i][j] = reward[i][j] + \max(dp[i-1][j], dp[i][j-1])
        		$
  - `dp[i][j]` 表示到达格子 `(i, j)` 的最大收益和。
  - 其中，`dp[i-1][j]` 是从上方到达该格子的最大收益，`dp[i][j-1]` 是从左方到达该格子的最大收益。



# 第二小问

### 1. 问题描述
给定一个 `n × n` 的二维矩阵 `reward`，每个格子有一个正整数作为奖励。我们从左上角 `(0, 0)` 出发，只能向下或向右走，最后走到右下角 `(n-1, n-1)`。我们需要找到一条路径，使得经过的格子中所有奖励的和最大化，并输出路径和最大奖励。。

### 2. 动态规划的思路
这道题目可以用 **动态规划** 来解决，问题的核心是将大问题拆解为多个子问题。我们通过递推关系，构建一个 `dp` 表（二维数组）来存储每一步的最优解，从而得到整体的最优解。

#### (1) 最优子结构
最优子结构是动态规划问题的核心。对于本题，每一个格子 `(i, j)` 的最优解依赖于其上方 `(i-1, j)` 和左方 `(i, j-1)` 的最优解。即问题的最优解包含了其子问题的最优解。我们可以得出下面的递推公式：
- 如果要到达 `(i, j)`，只能从上面或左边走过来。因此：
  $
  dp[i][j] = reward[i][j] + \max(dp[i-1][j], dp[i][j-1])
  $
  - `dp[i][j]` 表示到达格子 `(i, j)` 的最大奖励和。
  - 其中，`dp[i-1][j]` 是从上方到达该格子的最大奖励，`dp[i][j-1]` 是从左方到达该格子的最大奖励。

#### (2) 重叠子问题
重叠子问题体现在同一个格子的最优解会被多个路径计算到。动态规划通过存储每个格子的最优解，避免了对同一个子问题的重复计算。

例如，对于格子 `(i, j)` 来说，如果我们已经计算出了 `dp[i-1][j]` 和 `dp[i][j-1]` 的值，那么无需重新计算。每个格子都只需要计算一次，保证了算法的效率。

#### (3) 基本情况初始化
1. `dp[0][0]` 初始化为 `reward[0][0]`，因为它是起点。

2. 第一行的格子只能从左边走过来，因此：

   ​									$dp[0][j] = dp[0][j-1] + reward[0][j]   $

   第一列的格子只能从上方走过来，因此：
   									$dp[i][0] = dp[i-1][0] + reward[i][0]$

#### (4) 路径回溯
为了找出从左上角到右下角的路径，我们在 `dp` 数组计算完成后，可以从右下角 `(n-1, n-1)` 回溯路径。
- 每次选择当前格子 `dp[i][j]` 是从上方 `dp[i-1][j]` 还是左方 `dp[i][j-1]` 来的。我们总是选择更大的那个值，因为这对应着更高的总奖励。
- 回溯一直到 `(0, 0)` 为止，最终将路径反转得到从左上角到右下角的顺序。

### 3. 算法实现步骤
1. **初始化**：创建 `dp` 表格，大小为 `n × n`。并将 `dp[0][0]` 设为 `reward[0][0]`。
2. **填表**：按照上述递推公式逐步填充 `dp` 表，计算每个格子可以获得的最大奖励。
3. **回溯路径**：从右下角开始，逐步回溯到左上角，并记录经过的格子。
4. **输出结果**：返回最大奖励和经过的路径。

### 4. 时间复杂度与空间复杂度分析
#### 时间复杂度
- **计算 `dp` 表**：对于 `n × n` 的表格，我们需要遍历每个格子一次，计算递推关系。因此时间复杂度为 \(O(n^2)\)。
- **路径回溯**：路径回溯的过程同样是遍历从右下角到左上角的格子，因此复杂度为 \(O(n)\)。
- 整体时间复杂度为 $O(n^2)$。

#### 空间复杂度
- **`dp` 数组**：我们需要一个 `n × n` 的二维数组来存储每个格子的最优解，因此空间复杂度为 \(O(n^2)\)。
- **路径存储**：路径需要一个最多存储 `2n-1` 个格子的数组，空间复杂度为 \(O(n)\)。
- 整体空间复杂度为$ O(n^2)$。



#### 代码实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm>  // std::max
using namespace std;

// 计算最大奖励的函数
int calculateMaxReward(const vector<vector<int>>& reward, vector<vector<int>>& dp) {
    int n = reward.size();
    
    // 初始化dp数组
    dp[0][0] = reward[0][0];
    
    // 初始化第一行（只能从左边到达）
    for (int j = 1; j < n; j++) {
        dp[0][j] = dp[0][j-1] + reward[0][j];
    }
    
    // 初始化第一列（只能从上面到达）
    for (int i = 1; i < n; i++) {
        dp[i][0] = dp[i-1][0] + reward[i][0];
    }
    
    // 计算其余格子的最大收益
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = reward[i][j] + max(dp[i-1][j], dp[i][j-1]);
        }
    }
    
    // 返回从左上角到右下角的最大收益
    return dp[n-1][n-1];
}

// 回溯路径的函数
void findPath(const vector<vector<int>>& dp, vector<pair<int, int>>& path) {
    int i = dp.size() - 1;
    int j = dp[0].size() - 1;
    
    // 从右下角回溯到左上角
    while (i > 0 || j > 0) {
        path.push_back({i, j});
        // 如果在第一列，只能从上方来
        if (i > 0 && j > 0) {
            if (dp[i-1][j] > dp[i][j-1]) {
                i--;  // 从上方来
            } else {
                j--;  // 从左边来
            }
        } else if (i > 0) {
            i--;  // 只能从上方来
        } else {
            j--;  // 只能从左边来
        }
    }
    
    // 别忘了添加起点
    path.push_back({0, 0});
    
    // 将路径反转，使其从起点到终点
    reverse(path.begin(), path.end());
}

int main() {
    // 示例矩阵
    vector<vector<int>> reward = {
        {100, 200, 200, 200},
        {300, 100, 100, 200},
        {200, 500, 600, 400},
        {100, 400, 500, 800}
    };
    
    int n = reward.size();
    
    // 用于存储从左上到右下的最大收益的dp数组
    vector<vector<int>> dp(n, vector<int>(n, 0));
    
    // 用于存储路径
    vector<pair<int, int>> path;
    
    // 计算最大收益
    int result = calculateMaxReward(reward, dp);
   
    // 回溯路径
    findPath(dp, path);
    
    // 输出最大收益
    cout << "最大收益: " << result << endl;
    
    // 输出路径
    cout << "路径: ";
    for (const auto& p : path) {
        cout << "(" << p.first << ", " << p.second << ") ";
    }
    cout << endl;
    return 0;
}
```

### 输出
```
最大收益: 3000
路径: (0, 0) (1, 0) (2, 0) (2, 1) (2, 2) (3, 2) (3, 3) 
```

### 总结
- **递推公式**：通过 `dp[i][j] = reward[i][j] + max(dp[i-1][j], dp[i][j-1])`，逐步填充 `dp` 表。
- **路径回溯**：从终点回溯到起点，通过 `dp` 表找到路径上每个格子。
- **复杂度**：由于需要遍历 `n × n` 的矩阵，所以时间复杂度是 $O(n^2)$。整体空间复杂度为$ O(n^2)$。



# 老师辛苦啦！